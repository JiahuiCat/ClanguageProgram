#include<stdio.h>
/* example 7.5分别用递推方法和递归方法求n！，即1* 2 * 3 * ... * n. */

/* 
resolve 用递进方法，即从1开始，乘2，再乘3... ... 一直乘到n。这种方法容易理解，也容易实现。
递进法的特点是从一个已知的事实出发，按一定规律推出下一个事实，再从这个新的已知的事实出发，再向下推出一个新的事实
这是和递归不同的.
 */

/* long fac(int n){//定义fac函数
    int i;
    long fac=1;
    for(i=1;i<=n;i++) fac=fac*i;//计算n！
    return fac;
}

int main(){
    long fac(int n);//对long fac函数进行声明
    int n;
    long fact=0;//变量fact用来存放n！的值
    printf("please input a integer number:");//请用户输入n
    scanf("%d",&n);//输入n
    fact=fac(n);//调用fac函数求出n!
    printf("%d!=%ld\n",n,fact);//输出n！
    return 0;
} */

/* 程序分析:fac函数是用来连乘的方法求n！。
考虑到有的c编译系统整型数据的范围是-32768~32767,而当n的值等于8时，
就超过此范围，因此把函数fac和存放n!的变量fac和fact定义为long型。如果所用的c编译系统对整型数据分配4字节，
可以把程序中的long型都改为int型，结果相同。 */

/* ============================================================ */

/* 2.用递归方法求 n!
resolve 递归的思路和递推是相反的，并不是先求 1 * 2 * 3...直到 * n，而是直接从目标出发提出问题
现在要求 5! ，怎么样才能得到 5! 如果知道4！，就能通过4！* 5得到5！。而 4！也不知道，先求出 3!
就能通过 3！，就能通过 3! * 4得到 4！。而 3！也不知道，要先知道 2！，才能通过 2！* 3得到3！。
而 2！等于 1！ * 2.而 1！是已知的，不必再回溯了。
 */

/* 递归公式
n!= 1 (n=0,1)
    n.(n-1)! (n>1)
 */


long fac(int n)//定义fac函数
{
    long f;
    if(n<0)
        printf("n<0,data error!");//如果n<0,输出data,error
    else if(n==0,n==1)
        f=1;//否则如果 0! 和 1!等于1
    else f=fac(n-1) * n;//递归调用fac函数
    return(f);//f就是n
}

/* if(表达式) {语句}
功能：如果表达式为真，就执行下面的语句；如果表达式为假，就不执行下面的语句。 */

/* 因为在C语言中，if 只能控制其后的一个语句。如果要控制多个语句就必须加大括号{}。 */

int main(){
    long fac(int n);//对fac函数的声明
    int n,y;
    printf("input an integer number:");
    scanf("%d",&n);
    y=fac(n);//调用函数
    printf("%d!=%ld\n",n,y);
    return 0;
}

/* 程序分析:
在执行fac(5)的过程中，由于5不等于0和1，所以执行""f=fac(n-1)*n";,
即f=fac(4)*5,需要递归调用fac函数，即调用fac(4).
在执行fac(4)的过程中，由于4不等于0和1，所以执行""f=fac(n-1)*n;",
由于此时n=4了，所以相当于f=fac(3)*4. ...
由于此时n=2,所以相当于 f =fac(1) * 2。
在执行fac(1)的过程中，由于1等于1，所以执行""f=1;",不再递归调用fac函数，即递归调用结束
 */

/* 执行fac(1)的过程中，在执行完""f=1;"后，就执行return语句，f的值(1)就是函数fac(1)的值，
return语句将f的值1带回f=fac(1)* 2中，此时fac(1)已结束了，在执行fac(2)的过程中，
求出f=fac(1)*2= 1*2=2.
...fac(5)中的""f=fac(4) * 5"中，求出f=24 * 5 =120.由于fac(5)是main函数调用，
所以return语句将120作为fac(5)的值返回main函数的""y=fac(n)"中，即y=fac(5),
故y等于120，程序输出120(即5！的值)后结束

即执行""未知 -> 未知 -> ......直到出现递归边界条件",然后执行""已知 -> 已知 -> 已知"的过程。

 */